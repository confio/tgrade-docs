(self.webpackChunktgrade_docs=self.webpackChunktgrade_docs||[]).push([[14],{3905:function(t,e,n){"use strict";n.d(e,{Zo:function(){return u},kt:function(){return p}});var a=n(7294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function c(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},o=Object.keys(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var i=a.createContext({}),d=function(t){var e=a.useContext(i),n=e;return t&&(n="function"==typeof t?t(e):c(c({},e),t)),n},u=function(t){var e=d(t.components);return a.createElement(i.Provider,{value:e},t.children)},l={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},m=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,o=t.originalType,i=t.parentName,u=s(t,["components","mdxType","originalType","parentName"]),m=d(n),p=r,w=m["".concat(i,".").concat(p)]||m[p]||l[p]||o;return n?a.createElement(w,c(c({ref:e},u),{},{components:n})):a.createElement(w,c({ref:e},u))}));function p(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var o=n.length,c=new Array(o);c[0]=m;var s={};for(var i in e)hasOwnProperty.call(e,i)&&(s[i]=e[i]);s.originalType=t,s.mdxType="string"==typeof t?t:r,c[1]=s;for(var d=2;d<o;d++)c[d]=n[d];return a.createElement.apply(null,c)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8483:function(t,e,n){"use strict";n.r(e),n.d(e,{frontMatter:function(){return s},contentTitle:function(){return i},metadata:function(){return d},toc:function(){return u},default:function(){return m}});var a=n(2122),r=n(9756),o=(n(7294),n(3905)),c=["components"],s={sidebar_position:5},i="Uploading and Interacting",d={unversionedId:"smart-contracts/interact-with-contract",id:"smart-contracts/interact-with-contract",isDocsHomePage:!1,title:"Uploading and Interacting",description:"We have the binary ready. Now it is time to see some wasm action.",source:"@site/developer/02-smart-contracts/05-interact-with-contract.md",sourceDirName:"02-smart-contracts",slug:"/smart-contracts/interact-with-contract",permalink:"/tgrade-docs/developer/smart-contracts/smart-contracts/interact-with-contract",editUrl:"https://github.com/confio/tgrade-docs/edit/main/developer/02-smart-contracts/05-interact-with-contract.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"wikiSidebar",previous:{title:"Downloading and Compiling Contract",permalink:"/tgrade-docs/developer/smart-contracts/smart-contracts/compile-contract"},next:{title:"Next Steps",permalink:"/tgrade-docs/developer/smart-contracts/smart-contracts/next-steps"}},u=[{value:"Go CLI",id:"go-cli",children:[{value:"Instantiating the Contract",id:"instantiating-the-contract",children:[]}]}],l={toc:u};function m(t){var e=t.components,n=(0,r.Z)(t,c);return(0,o.kt)("wrapper",(0,a.Z)({},l,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"uploading-and-interacting"},"Uploading and Interacting"),(0,o.kt)("p",null,"We have the binary ready. Now it is time to see some wasm action."),(0,o.kt)("h2",{id:"go-cli"},"Go CLI"),(0,o.kt)("p",null,"We generated a wasm binary executable in the previous chapter. Let's put it into use. Now, we will upload the code to\nthe blockchain. Afterwards, you can download the bytecode to verify it is proper:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"# see how many codes we have now\nwasmd query wasm list-code $NODE\n\n# gas is huge due to wasm size... but auto-zipping reduced this from 1.8M to around 600k\n# you can see the code in the result\nRES=$(wasmd tx wasm store artifacts/cw_nameservice.wasm --from wallet $TXFLAG -y)\n\n# you can also get the code this way\nCODE_ID=$(echo $RES | jq -r '.logs[0].events[-1].attributes[0].value')\n\n# no contracts yet, this should return an empty list\nwasmd query wasm list-contract-by-code $CODE_ID $NODE --output json\n\n# you can also download the wasm from the chain and check that the diff between them is empty\nwasmd query wasm code $CODE_ID $NODE download.wasm\ndiff artifacts/cw_nameservice.wasm download.wasm\n")),(0,o.kt)("h3",{id:"instantiating-the-contract"},"Instantiating the Contract"),(0,o.kt)("p",null,"We can now create an instance of this wasm contract. We instantiate smart contract with defined purchase and transfer price."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},'# instantiate contract and verify\nINIT=\'{"purchase_price":{"amount":"100","denom":"utgd"},"transfer_price":{"amount":"999","denom":"utgd"}}\'\nwasmd tx wasm instantiate $CODE_ID "$INIT" \\\n    --from wallet --label "awesome name service" $TXFLAG -y\n\n# check the contract state (and account balance)\nwasmd query wasm list-contract-by-code $CODE_ID $NODE --output json\nCONTRACT=$(wasmd query wasm list-contract-by-code $CODE_ID $NODE --output json | jq -r \'.contracts[-1]\')\necho $CONTRACT\n\nwasmd query wasm contract $CONTRACT $NODE --output json\n\n# you can dump entire contract state\nwasmd query wasm contract-state all $CONTRACT $NODE --output json\n\n# Note that keys are hex encoded, and val is base64 encoded.\n# To view the returned data (assuming it is ascii), try something like:\n# (Note that in many cases the binary data returned is non in ascii format, thus the encoding)\nwasmd query wasm contract-state all $CONTRACT $NODE --output "json" | jq -r \'.models[0].key\' | xxd -r -ps\nwasmd query wasm contract-state all $CONTRACT $NODE --output "json" | jq -r \'.models[0].value\' | base64 -d\n\n# or try a "smart query", executing against the contract\nwasmd query wasm contract-state smart $CONTRACT \'{}\' $NODE\n# (since we didn\'t implement any valid QueryMsg, we just get a parse error back)\n')),(0,o.kt)("p",null,"Once contract instantiated, let's register a name and transfer it with paying its price."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},'# execute fails if wrong person\nREGISTER=\'{"register":{"name":"freddy"}}\'\nwasmd tx wasm execute $CONTRACT "$REGISTER" \\\n    --amount 100utgd \\\n    --from wallet $TXFLAG -y\n\n# query name record\nNAME_QUERY=\'{"resolve_record": {"name": "freddy"}}\'\nwasmd query wasm contract-state smart $CONTRACT "$NAME_QUERY" $NODE --output json\n# {"data":{"address":"tgrade1av9uhya7ltnusvunyqay3xcv9x0nyc872cheu5"}}\n\n# buy and transfer name record to wallet2\nTRANSFER=\'{"transfer":{"name":"freddy", "to": "tgrade149mvf8wrumxz45lg3tdpgylwxrpw7gyav58cu6"}}\'\nwasmd tx wasm execute $CONTRACT "$TRANSFER" \\\n    --amount 999utgd \\\n    --from wallet $TXFLAG -y\n')),(0,o.kt)("p",null,"Query record to see the new owner address:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},'NAME_QUERY=\'{"resolve_record": {"name": "freddy"}}\'\nwasmd query wasm contract-state smart $CONTRACT "$NAME_QUERY" $NODE --output json\n# {"data":{"address":"tgrade149mvf8wrumxz45lg3tdpgylwxrpw7gyav58cu6"}}\n')))}m.isMDXComponent=!0}}]);